<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Puzzle Physics Game</title>
<style>
  body { margin:0; background:#222; }
  canvas { display:block; margin:auto; background:#f5f2ec; }
</style>
</head>
<body>
<canvas id="c" width="420" height="640"></canvas>

<script>
/* =========================
   基本設定
========================= */
const cv = document.getElementById("c");
const ctx = cv.getContext("2d");
let gameTime = 0;

const ball = {
  x: 210, y: 600, r: 8,
  vx: 0, vy: 0,
  active: false
};

let aiming = false;
let aimX = 0, aimY = 0;

let currentStage = 0;
let switchOn = false;

/* =========================
   ステージテンプレ
========================= */
const STAGES = [
  {
    start:{x:210,y:600},
    blocks:[
      {x:60,y:450,w:300,h:10},
      {x:80,y:300,w:120,h:10},
    ],
    switches:[
      {x:300,y:280,w:40,h:10}
    ],
    gates:[
      {x:200,y:200,w:160,h:10}
    ],
    holes:[
      {x:190,y:120,w:40}
    ]
  }
];

/* =========================
   リセット
========================= */
function resetStage(){
  const s = STAGES[currentStage];
  ball.x = s.start.x;
  ball.y = s.start.y;
  ball.vx = ball.vy = 0;
  ball.active = false;
  aiming = false;
  switchOn = false;
  gameTime = 0;
}

/* =========================
   入力
========================= */
cv.addEventListener("mousedown",e=>{
  if(ball.active) return;
  aiming = true;
  aimX = e.offsetX;
  aimY = e.offsetY;
});
cv.addEventListener("mousemove",e=>{
  if(!aiming) return;
  aimX = e.offsetX;
  aimY = e.offsetY;
});
cv.addEventListener("mouseup",e=>{
  if(!aiming) return;
  aiming = false;
  const dx = ball.x - aimX;
  const dy = ball.y - aimY;
  ball.vx = dx * 0.1;
  ball.vy = dy * 0.1;
  ball.active = true;
});

/* =========================
   更新
========================= */
function update(){
  gameTime++;

  if(ball.active){
    ball.vy += 0.5;
    ball.x += ball.vx;
    ball.y += ball.vy;
  }

  const s = STAGES[currentStage];

  // 壁
  if(ball.x < ball.r || ball.x > cv.width-ball.r) ball.vx *= -0.6;
  if(ball.y < ball.r) ball.vy *= -0.6;

  // ブロック
  [...s.blocks, ...(switchOn ? [] : s.gates)].forEach(b=>{
    if(
      ball.x+ball.r>b.x &&
      ball.x-ball.r<b.x+b.w &&
      ball.y+ball.r>b.y &&
      ball.y-ball.r<b.y+b.h
    ){
      const prevY = ball.y - ball.vy;
      if(prevY+ball.r<=b.y){
        ball.y=b.y-ball.r;
        ball.vy*=-0.6;
      }else{
        ball.vx*=-0.15;
      }
    }
  });

  // スイッチ
  s.switches.forEach(sw=>{
    if(
      ball.x>sw.x && ball.x<sw.x+sw.w &&
      ball.y+ball.r>sw.y && ball.y-ball.r<sw.y+sw.h
    ){
      switchOn = true;
    }
  });

  // 穴
  s.holes.forEach(h=>{
    if(ball.x>h.x && ball.x<h.x+h.w && ball.y>h.y){
      ball.vy += 1.2;
      if(ball.y>cv.height+40){
        currentStage++;
        if(currentStage>=STAGES.length){
          alert("CLEAR!");
          currentStage=0;
        }
        resetStage();
      }
    }
  });

  // 落下ミス
  if(ball.y>cv.height+50){
    resetStage();
  }
}

/* =========================
   描画
========================= */
function draw(){
  ctx.clearRect(0,0,cv.width,cv.height);

  const s = STAGES[currentStage];

  // 予測線
  if(aiming){
    ctx.strokeStyle="rgba(0,0,0,0.4)";
    ctx.beginPath();
    ctx.moveTo(ball.x,ball.y);
    ctx.lineTo(aimX,aimY);
    ctx.stroke();
  }

  // ブロック
  ctx.fillStyle="#333";
  s.blocks.forEach(b=>ctx.fillRect(b.x,b.y,b.w,b.h));

  // ゲート
  if(!switchOn){
    ctx.fillStyle="#a33";
    s.gates.forEach(b=>ctx.fillRect(b.x,b.y,b.w,b.h));
  }

  // スイッチ
  ctx.fillStyle=switchOn?"#6c6":"#6aa";
  s.switches.forEach(sw=>ctx.fillRect(sw.x,sw.y,sw.w,sw.h));

  // 穴
  ctx.fillStyle="#000";
  s.holes.forEach(h=>{
    ctx.beginPath();
    ctx.arc(h.x+h.w/2,h.y,18,0,Math.PI*2);
    ctx.fill();
  });

  // ボール
  ctx.fillStyle="#555";
  ctx.beginPath();
  ctx.arc(ball.x,ball.y,ball.r,0,Math.PI*2);
  ctx.fill();
}

/* =========================
   ループ
========================= */
function loop(){
  update();
  draw();
  requestAnimationFrame(loop);
}

resetStage();
loop();
</script>
</body>
</html>
