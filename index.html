<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
<title>ver 5.3.1</title>
<style>
body{margin:0;background:#0f172a;overflow:hidden;touch-action:none;font-family:sans-serif}
canvas{display:block}
.ui-layer{position:absolute;inset:0;pointer-events:none;color:white}
.st-info{position:absolute;top:20px;width:100%;text-align:center}
.retry-btn{position:absolute;bottom:20px;left:20px;padding:12px 25px;background:white;color:black;border-radius:20px;font-weight:bold;pointer-events:auto}
</style>
</head>
<body>

<canvas id="gameCanvas"></canvas>
<div class="ui-layer">
  <div class="st-info">
    <h2 id="stName"></h2>
    <p id="stHint"></p>
  </div>
  <div class="retry-btn" onclick="resetStage()">RETRY</div>
</div>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

let W,H,gameTime=0,currentStage=0;
const stages=[];
const ball={x:0,y:0,r:13,vx:0,vy:0,moving:false,inHole:false};
const touch={active:false,sx:0,sy:0,cx:0,cy:0};

function createStages(){
stages.length=0;
for(let i=1;i<=20;i++){
const s={
name:`STAGE ${i}`,
hint:"穴へ落とそう",
hX:0.8,
hW:Math.max(40,85-i*2),
gY:0.8,
dynHole:i%7===0,
obs:[]
};
if(i===1) s.obs.push({t:"block",x:.5,y:.5,w:30,h:200});
else if(i===2) s.obs.push({t:"rot",x:.6,y:.4,l:100,s:.07});
else if(i===3){s.hint="加速パッド";s.obs.push({t:"accel",x:.4,y:.78,w:100,p:12});}
else if(i===4){s.hint="ワープゾーン";s.obs.push({t:"warp",x:.3,y:.7,tx:.7,ty:.2});}
else if(i===5){s.hint="動く床";s.obs.push({t:"move",x:.3,y:.6,w:120,h:20,r:150,s:2});}
else if(i===6){s.hint="低重力";s.obs.push({t:"lowG",x:.35,y:.1,w:.25,h:.5});}
else{
if(i%3===0) s.obs.push({t:"move",x:.25,y:.5,w:100,h:20,r:150,s:i*.15});
if(i%2===0) s.obs.push({t:"rot",x:.5,y:.3,l:80,s:.05+i*.004});
if(i>10) s.obs.push({t:"spike",x:.3,y:.78,w:120});
}
stages.push(s);
}
}

function resize(){
W=innerWidth;H=innerHeight;
canvas.width=W;canvas.height=H;
resetStage();
}

function resetStage(){
const s=stages[currentStage];
ball.x=80;
ball.y=H*s.gY-ball.r-20;
ball.vx=ball.vy=0;
ball.moving=false;
ball.inHole=false;
stName.textContent=s.name;
stHint.textContent=s.hint;
}

addEventListener("touchstart",e=>{
if(!ball.moving){
touch.active=true;
touch.sx=touch.cx=e.touches[0].clientX;
touch.sy=touch.cy=e.touches[0].clientY;
}}, {passive:false});

addEventListener("touchmove",e=>{
if(touch.active){
touch.cx=e.touches[0].clientX;
touch.cy=e.touches[0].clientY;
}
e.preventDefault();
},{passive:false});

addEventListener("touchend",()=>{
if(touch.active){
ball.vx=(touch.sx-touch.cx)*0.13;
ball.vy=(touch.sy-touch.cy)*0.13;
ball.moving=true;
touch.active=false;
}});

function loop(){
gameTime++;
ctx.fillStyle="#0f172a";
ctx.fillRect(0,0,W,H);

const s=stages[currentStage];
const gY=H*s.gY;
let hW=s.hW+(s.dynHole?Math.sin(gameTime*.07)*25:0);
const hL=W*s.hX-hW/2;
let curG=.5;

ctx.fillStyle="#10b981";
ctx.fillRect(0,gY,W,H-gY);
ctx.fillStyle="#000";
ctx.fillRect(hL,gY,hW,100);

s.obs.forEach(o=>{
if(o.t==="lowG"){
const x=o.x*W,y=o.y*H,w=o.w*W,h=o.h*H;
ctx.fillStyle="rgba(56,189,248,.15)";
ctx.fillRect(x,y,w,h);
if(ball.x>x&&ball.x<x+w&&ball.y>y&&ball.y<y+h)curG=.15;
}

if(o.t==="warp"){
ctx.beginPath();
ctx.arc(o.x*W,o.y*H,25,0,Math.PI*2);
ctx.strokeStyle="#38bdf8";
ctx.lineWidth=2;
ctx.stroke();
if(Math.hypot(ball.x-o.x*W,ball.y-o.y*H)<25){
ball.x=o.tx*W;
ball.y=o.ty*H;
}
}

if(o.t==="accel"){
ctx.fillStyle="#facc15";
ctx.fillRect(o.x*W,gY-6,o.w,6);
if(ball.x>o.x*W&&ball.x<o.x*W+o.w&&Math.abs(ball.y+ball.r-gY)<12){
ball.vx+=o.p*Math.sign(ball.vx||1);
}
}

if(o.t==="block"||o.t==="move"){
if(o.t==="move"){
o.cX=(o.cX??o.x*W)+(o.d??1)*o.s;
if(o.cX>o.x*W+o.r||o.cX<o.x*W)o.d=(o.d??1)*-1;
}
const bx=o.t==="move"?o.cX:o.x*W;
const by=o.y*H;
ctx.fillStyle="#64748b";
ctx.fillRect(bx,by,o.w,o.h);
if(ball.x+ball.r>bx&&ball.x-ball.r<bx+o.w&&ball.y+ball.r>by&&ball.y-ball.r<by+o.h){
ball.vx*=-.7;ball.vy*=-.7;
}
}

if(o.t==="rot"){
o.a=(o.a||0)+o.s;
const x1=o.x*W,y1=o.y*H;
const x2=x1+Math.cos(o.a)*o.l;
const y2=y1+Math.sin(o.a)*o.l;
ctx.strokeStyle="#fbbf24";
ctx.lineWidth=8;
ctx.beginPath();
ctx.moveTo(x1,y1);
ctx.lineTo(x2,y2);
ctx.stroke();
const dx=x2-x1,dy=y2-y1;
const t=Math.max(0,Math.min(1,((ball.x-x1)*dx+(ball.y-y1)*dy)/(dx*dx+dy*dy)));
if(Math.hypot(ball.x-(x1+t*dx),ball.y-(y1+t*dy))<ball.r){
ball.vx*=-1.1;ball.vy*=-1.1;
}
}

if(o.t==="spike"){
ctx.fillStyle="#ef4444";
for(let j=0;j<o.w;j+=20){
ctx.beginPath();
ctx.moveTo(o.x*W+j,gY);
ctx.lineTo(o.x*W+j+10,gY-20);
ctx.lineTo(o.x*W+j+20,gY);
ctx.fill();
}
if(ball.x>o.x*W&&ball.x<o.x*W+o.w&&ball.y+ball.r>gY-5&&!ball.inHole){
resetStage();
}
}
});

if(ball.moving){
ball.vy+=curG;
ball.x+=ball.vx;
ball.y+=ball.vy;
if(ball.y+ball.r>gY){
if(ball.x>hL&&ball.x<hL+hW){
ball.inHole=true;
ball.vx*=.95;
ball.vy*=.95;
}else if(!ball.inHole){
ball.y=gY-ball.r;
ball.vy*=-.3;
ball.vx*=.8;
}
}
}

if(touch.active){
ctx.setLineDash([5,5]);
ctx.strokeStyle="white";
ctx.beginPath();
ctx.moveTo(ball.x,ball.y);
ctx.lineTo(ball.x+(touch.sx-touch.cx)*.6,ball.y+(touch.sy-touch.cy)*.6);
ctx.stroke();
ctx.setLineDash([]);
}

ctx.beginPath();
ctx.arc(ball.x,ball.y,ball.r,0,Math.PI*2);
ctx.fillStyle="white";
ctx.fill();
ctx.strokeStyle="black";
ctx.lineWidth=2;
ctx.stroke();

if(ball.inHole&&Math.abs(ball.vx)+Math.abs(ball.vy)<0.4){
currentStage=(currentStage+1)%stages.length;
resetStage();
}

if(ball.x<-50||ball.x>W+50||ball.y>H+80) resetStage();

requestAnimationFrame(loop);
}

createStages();
addEventListener("resize",resize);
resize();
loop();
</script>
</body>
</html>
