<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
<title>ver 5.3.5</title>
<style>
body{margin:0;background:#0f172a;overflow:hidden;touch-action:none;font-family:sans-serif}
canvas{display:block}
.ui-layer{position:absolute;inset:0;pointer-events:none;color:white}
.st-info{position:absolute;top:20px;width:100%;text-align:center}
.retry-btn{position:absolute;bottom:20px;left:20px;padding:12px 25px;background:white;color:black;border-radius:20px;font-weight:bold;pointer-events:auto}
</style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<div class="ui-layer">
  <div class="st-info">
    <h2 id="stName"></h2>
    <p id="stHint"></p>
  </div>
  <div class="retry-btn" onclick="resetStage()">RETRY</div>
</div>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

let W,H,gameTime=0,currentStage=0;
const stages=[];
const ball={
  x:0,y:0,r:13,baseR:13,
  vx:0,vy:0,
  moving:false,
  inHole:false,
  holeTime:0,
  alpha:1
};
const touch={active:false,sx:0,sy:0,cx:0,cy:0};

/* ===== ユーティリティ ===== */
function circleRectHit(cx,cy,cr,rx,ry,rw,rh){
  const nx=Math.max(rx,Math.min(cx,rx+rw));
  const ny=Math.max(ry,Math.min(cy,ry+rh));
  return Math.hypot(cx-nx,cy-ny)<=cr;
}

/* ===== ステージ生成 ===== */
function createStages(){
stages.length=0;
for(let i=1;i<=20;i++){
const s={
name:`STAGE ${i}`,
hint:"穴へ落とそう",
hX:0.8,
hW:Math.max(40,85-i*2),
gY:0.8,
dynHole:i%7===0,
obs:[]
};
if(i===1) s.obs.push({t:"block",x:.5,y:.55,w:30,h:200});
else if(i===5) s.obs.push({t:"move",x:.25,y:.6,w:140,h:22,r:120,s:1.5});
else{
if(i%3===0) s.obs.push({t:"move",x:.25,y:.55,w:120,h:20,r:160,s:1+i*.15});
if(i%2===0) s.obs.push({t:"block",x:.55,y:.5,w:40,h:180});
}
stages.push(s);
}
}

/* ===== 初期化 ===== */
function resize(){
W=innerWidth;H=innerHeight;
canvas.width=W;canvas.height=H;
}
function resetStage(){
const s=stages[currentStage];
ball.x=80;
ball.y=H*s.gY-ball.baseR-20;
ball.vx=ball.vy=0;
ball.r=ball.baseR;
ball.alpha=1;
ball.moving=false;
ball.inHole=false;
ball.holeTime=0;
stName.textContent=s.name;
stHint.textContent=s.hint;
}

/* ===== 入力 ===== */
addEventListener("touchstart",e=>{
if(!ball.moving){
touch.active=true;
touch.sx=touch.cx=e.touches[0].clientX;
touch.sy=touch.cy=e.touches[0].clientY;
}}, {passive:false});

addEventListener("touchmove",e=>{
if(touch.active){
touch.cx=e.touches[0].clientX;
touch.cy=e.touches[0].clientY;
}
e.preventDefault();
},{passive:false});

addEventListener("touchend",()=>{
if(touch.active){
ball.vx=(touch.sx-touch.cx)*0.13;
ball.vy=(touch.sy-touch.cy)*0.13;
ball.moving=true;
touch.active=false;
}});

/* ===== メインループ ===== */
function loop(){
gameTime++;
ctx.fillStyle="#0f172a";
ctx.fillRect(0,0,W,H);

const s=stages[currentStage];
const gY=H*s.gY;
let hW=s.hW+(s.dynHole?Math.sin(gameTime*.07)*25:0);
const hL=W*s.hX-hW/2;
const holeCX=hL+hW/2;
const holeCY=gY+10;

/* ===== 地面 & 穴 ===== */
ctx.fillStyle="#10b981";
ctx.fillRect(0,gY,W,H-gY);
ctx.fillStyle="#000";
ctx.fillRect(hL,gY,hW,100);

/* ===== 障害物 ===== */
s.obs.forEach(o=>{

/* --- block --- */
if(o.t==="block"){
const x=o.x*W,y=o.y*H,w=o.w,h=o.h;
ctx.fillStyle="#475569";
ctx.fillRect(x,y,w,h);

if(circleRectHit(ball.x,ball.y,ball.r,x,y,w,h)){
const prevY=ball.y-ball.vy;
if(prevY+ball.r<=y+6){
ball.y=y-ball.r;
ball.vy=0;
ball.vx*=0.85;
}else{
if(ball.x<x) ball.x=x-ball.r;
if(ball.x>x+w) ball.x=x+w+ball.r;
ball.vx*=0.3;
}
}
}

/* --- move --- */
if(o.t==="move"){
const baseX=o.x*W, baseY=o.y*H;
const ox=Math.sin(gameTime*0.02*o.s)*o.r;
const x=baseX+ox, y=baseY;

ctx.fillStyle="#22c55e";
ctx.fillRect(x,y,o.w,o.h);

if(circleRectHit(ball.x,ball.y,ball.r,x,y,o.w,o.h)){
const prevY=ball.y-ball.vy;
if(prevY+ball.r<=y+6){
ball.y=y-ball.r;
ball.vy=0;
ball.x+=ox-(o.prevOx||0);
}else{
ball.vx*=0.2;
}
}
o.prevOx=ox;
}

});

/* ===== 物理 ===== */
if(ball.moving && !ball.inHole){
ball.vy+=0.5;
ball.x+=ball.vx;
ball.y+=ball.vy;

if(ball.y+ball.r>gY){
if(ball.x>hL+ball.r*0.4 && ball.x<hL+hW-ball.r*0.4){
ball.inHole=true;
ball.vx=ball.vy=0;
}else{
ball.y=gY-ball.r;
ball.vy*=-0.3;
ball.vx*=0.8;
}
}
}

/* ===== 吸い込み演出 ===== */
if(ball.inHole){
ball.holeTime++;
ball.x+=(holeCX-ball.x)*0.15;
ball.y+=(holeCY-ball.y)*0.15;
ball.r*=0.94;
ball.alpha*=0.92;
}

/* ===== 予測線（復活） ===== */
if(touch.active && !ball.moving){
ctx.beginPath();
ctx.setLineDash([6,6]);
ctx.strokeStyle="rgba(255,255,255,0.8)";
ctx.lineWidth=2;
ctx.moveTo(ball.x,ball.y);
ctx.lineTo(
  ball.x+(touch.sx-touch.cx),
  ball.y+(touch.sy-touch.cy)
);
ctx.stroke();
ctx.setLineDash([]);
}

/* ===== ボール描画 ===== */
ctx.globalAlpha=ball.alpha;
ctx.beginPath();
ctx.arc(ball.x,ball.y,Math.max(0,ball.r),0,Math.PI*2);
ctx.fillStyle="white";
ctx.fill();
ctx.strokeStyle="black";
ctx.lineWidth=2;
ctx.stroke();
ctx.globalAlpha=1;

/* ===== ステージ遷移 ===== */
if(ball.inHole && ball.holeTime>35){
currentStage=(currentStage+1)%stages.length;
resetStage();
}

requestAnimationFrame(loop);
}

/* ===== 起動 ===== */
createStages();
addEventListener("resize",resize);
resize();
resetStage();
loop();
</script>
</body>
</html>
